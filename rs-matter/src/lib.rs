/*
 *
 *    Copyright (c) 2020-2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

//! Native Rust Implementation of Matter (Smart-Home)
//!
//! This crate implements the Matter specification that can be run on embedded devices
//! to build Matter-compatible smart-home/IoT devices.
//!
//! Currently Ethernet based transport is supported.
//!
//! # Examples
//! ```ignore
//! /// TODO: Fix once new API has stabilized a bit
//! use rs_matter::{Matter, CommissioningData};
//! use rs_matter::dm::device_types::device_type_add_on_off_light;
//! use rs_matter::dm::cluster_basic_information::BasicInfoConfig;
//! use rs_matter::sc::spake2p::VerifierData;
//!
//! # use rs_matter::dm::sdm::dev_att::{DataType, DevAttDataFetcher};
//! # use rs_matter::error::Error;
//! # pub struct DevAtt{}
//! # impl DevAttDataFetcher for DevAtt{
//! # fn get_devatt_data(&self, data_type: DataType, data: &mut [u8]) -> Result<usize, Error> { Ok(0) }
//! # }
//! # let dev_att = Box::new(DevAtt{});
//!
//! /// The commissioning data for this device
//! let comm_data = CommissioningData {
//!     verifier: VerifierData::new_with_pw(123456),
//!     discriminator: 250,
//! };
//!
//! /// The basic information about this device
//! let dev_info = BasicInfoConfig {
//!     vid: 0x8000,
//!     pid: 0xFFF1,
//!     hw_ver: 2,
//!     sw_ver: 1,
//!     sw_ver_str: "1".to_string(),
//!     serial_no: "aabbcc".to_string(),
//!     device_name: "OnOff Light".to_string(),
//! };
//!
//! /// Get the Matter Object
//! /// The dev_att is an object that implements the DevAttDataFetcher trait.
//! let mut matter = Matter::new(dev_info, dev_att, comm_data).unwrap();
//! let dm = matter.get_data_model();
//! {
//!     let mut node = dm.node.write().unwrap();
//!     /// Add our device-types
//!     let endpoint = device_type_add_on_off_light(&mut node).unwrap();
//! }
//! // Start the Matter Daemon
//! // matter.start_daemon().unwrap();
//! ```
//!
//! Start off exploring by going to the [Matter] object.
#![cfg_attr(not(feature = "std"), no_std)]
#![allow(async_fn_in_trait)]
#![allow(unknown_lints)]
#![allow(clippy::uninlined_format_args)]
#![recursion_limit = "1024"]

use core::future::Future;

use embassy_sync::blocking_mutex::raw::NoopRawMutex;

use crate::crypto::Crypto;
use crate::dm::clusters::basic_info::{BasicInfoConfig, BasicInfoSettings};
use crate::dm::clusters::dev_att::DeviceAttestation;
use crate::error::{Error, ErrorCode};
use crate::fabric::FabricMgr;
use crate::failsafe::FailSafe;
use crate::pairing::qr::{
    no_optional_data, CommFlowType, NoOptionalData, Qr, QrPayload, QrTextType,
};
use crate::pairing::DiscoveryCapabilities;
use crate::sc::pase::PaseMgr;
use crate::transport::network::{NetworkReceive, NetworkSend};
use crate::transport::TransportMgr;
use crate::utils::cell::RefCell;
use crate::utils::epoch::Epoch;
use crate::utils::init::{init, Init};
use crate::utils::rand::Rand;
use crate::utils::storage::pooled::BufferAccess;
use crate::utils::storage::WriteBuf;
use crate::utils::sync::Notification;

use crate::dm::{AttrId, BasicContextInstance, ChangeNotify, ClusterId, EndptId};
/// Re-export the `rs_matter_macros::import` proc-macro
pub use rs_matter_macros::import;

#[cfg(feature = "alloc")]
extern crate alloc;

// This mod MUST go first, so that the others see its macros.
pub(crate) mod fmt;

pub mod acl;
pub mod cert;
pub mod crypto;
pub mod dm;
pub mod error;
pub mod fabric;
pub mod failsafe;
pub mod group_keys;
pub mod im;
pub mod pairing;
pub mod persist;
pub mod respond;
pub mod sc;
pub mod tlv;
pub mod transport;
pub mod utils;

/// Re-export several crates
///
/// This is necessary for crates used in the code generated by the proc-macros
pub mod reexport {
    pub use bitflags;
    #[cfg(feature = "defmt")]
    pub use defmt;
    #[cfg(feature = "log")]
    pub use log;
    pub use strum;
}

#[cfg(feature = "alloc")]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        alloc::boxed::Box::new($val)
    };
}

#[cfg(not(feature = "alloc"))]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        $val
    };
}

/// The Matter UDP port
pub const MATTER_PORT: u16 = 5540;

/// The maximum length of a Matter mDNS service name
pub const MATTER_SERVICE_MAX_NAME_LEN: usize = 33;

/// A type capturing all the information necessary to publish a commissioned
/// Matter fabric or a non-commissioned Matter instance over mDNS.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum MatterMdnsService {
    /// A commissioned Matter service for a particular fabric
    ///
    /// The published name is in the form `<compressed-fabric-id-hex>-<node-id-hex>`.
    Commissioned {
        compressed_fabric_id: u64,
        node_id: u64,
    },
    /// A non-commissioned Matter service
    ///
    /// The published name is in the form `<id-hex>`. The discriminator should be used as an mDNS TXT entry
    Commissionable {
        id: u64,
        /// The discriminator to be communicated over mDNS
        discriminator: u16,
    },
}

impl MatterMdnsService {
    /// Return the name of the mDNS service in a buffer
    ///
    /// NOTE: The buffer needs to be at least `MATTER_SERVICE_MAX_NAME_LEN` bytes long
    /// or else this method will panic.
    pub fn name<'a>(&self, buf: &'a mut [u8]) -> &'a str {
        use core::fmt::Write;

        match self {
            Self::Commissioned {
                compressed_fabric_id,
                node_id,
            } => {
                if buf.len() < MATTER_SERVICE_MAX_NAME_LEN {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", compressed_fabric_id);

                unwrap!(wb.append(b"-"));

                write_unwrap!(&mut wb, "{:016X}", node_id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
            Self::Commissionable { id, .. } => {
                if buf.len() < 16 {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
        }
    }
}

/// Device basic commissioning data
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct BasicCommData {
    /// The password which is necessary to authenticate the device in either
    /// initial commissioning, or when the basic commissioning window is opened
    pub password: u32,
    /// The 12-bit discriminator used to differentiate between multiple devices
    pub discriminator: u16,
}

/// The primary Matter Object
pub struct Matter<'a> {
    pub fabric_mgr: RefCell<FabricMgr>, // Public for tests
    pub(crate) pase_mgr: RefCell<PaseMgr>,
    pub(crate) failsafe: RefCell<FailSafe>,
    pub(crate) basic_info_settings: RefCell<BasicInfoSettings>,
    pub transport_mgr: TransportMgr, // Public for tests
    persist_notification: Notification<NoopRawMutex>,
    mdns_notification: Notification<NoopRawMutex>,
    epoch: Epoch,
    rand: Rand,
    dev_det: &'a BasicInfoConfig<'a>,
    dev_comm: BasicCommData,
    dev_att: &'a dyn DeviceAttestation,
    port: u16,
}

impl<'a> Matter<'a> {
    /// Create a new Matter object when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    #[inline(always)]
    pub const fn new_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DeviceAttestation,
        port: u16,
    ) -> Self {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::new(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create a new Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[inline(always)]
    pub const fn new(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DeviceAttestation,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> Self {
        Self {
            fabric_mgr: RefCell::new(FabricMgr::new()),
            pase_mgr: RefCell::new(PaseMgr::new(epoch, rand)),
            failsafe: RefCell::new(FailSafe::new(epoch, rand)),
            transport_mgr: TransportMgr::new(dev_det, epoch, rand),
            basic_info_settings: RefCell::new(BasicInfoSettings::new()),
            persist_notification: Notification::new(),
            mdns_notification: Notification::new(),
            epoch,
            rand,
            dev_det,
            dev_comm,
            dev_att,
            port,
        }
    }

    /// Create an in-place initializer for a Matter object
    /// when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    pub fn init_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DeviceAttestation,
        port: u16,
    ) -> impl Init<Self> {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::init(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create an in-place initializer for a Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    pub fn init(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DeviceAttestation,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> impl Init<Self> {
        init!(
            Self {
                fabric_mgr <- RefCell::init(FabricMgr::init()),
                pase_mgr <- RefCell::init(PaseMgr::init(epoch, rand)),
                failsafe: RefCell::new(FailSafe::new(epoch, rand)),
                transport_mgr <- TransportMgr::init(dev_det, epoch, rand),
                basic_info_settings <- RefCell::init(BasicInfoSettings::init()),
                persist_notification: Notification::new(),
                mdns_notification: Notification::new(),
                epoch,
                rand,
                dev_det,
                dev_comm,
                dev_att,
                port,
            }
        )
    }

    pub fn initialize_transport_buffers(&self) -> Result<(), Error> {
        self.transport_mgr.initialize_buffers()
    }

    pub fn dev_det(&self) -> &BasicInfoConfig<'_> {
        self.dev_det
    }

    pub fn dev_att(&self) -> &dyn DeviceAttestation {
        self.dev_att
    }

    pub fn dev_comm(&self) -> &BasicCommData {
        &self.dev_comm
    }

    pub fn port(&self) -> u16 {
        self.port
    }

    pub fn rand(&self) -> Rand {
        self.rand
    }

    pub fn epoch(&self) -> Epoch {
        self.epoch
    }

    pub fn transport_rx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.rx_buffer()
    }

    pub fn transport_tx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.tx_buffer()
    }

    /// A utility method to replace the initial Device Attestation with another one.
    pub fn replace_dev_att(&mut self, dev_att: &'a dyn DeviceAttestation) {
        self.dev_att = dev_att;
    }

    /// Print the standard QR code text to the console
    ///
    /// The printed QR code text corresponds to the standard commissioning flow (i.e. `CommFlowType::Standard`)
    /// and contains no optional data.
    ///
    /// This method is useful primarily during development, when the Matter device is
    /// attached to a console. It is expected that the developer will call this method prior to running the Matter transport.
    ///
    /// # Arguments
    /// - `disc_caps`: The discovery capabilities to be used in the QR code payload
    pub fn print_standard_qr_text(&self, disc_caps: DiscoveryCapabilities) -> Result<(), Error> {
        let rx_buf = self.transport_mgr.rx_buffer();

        let mut buf = rx_buf.get_immediate().ok_or(ErrorCode::NoMemory)?;
        let buf = &mut *buf;

        let payload = self.standard_qr_payload(disc_caps)?;

        let (text, _) = payload.as_str(buf)?;

        // Do not remove this logging line or change its formatting.
        // C++ E2E tests rely on this log line to grep the QR code
        info!("SetupQRCode: [{}]", text);

        Ok(())
    }

    /// Print the standard QR code to the console
    ///
    /// The printed QR code corresponds to the standard commissioning flow (i.e. `CommFlowType::Standard`)
    /// and contains no optional data.
    ///
    /// This method is useful primarily during development, when the Matter device is
    /// attached to a console. It is expected that the developer will call this method prior to running the Matter transport.
    ///
    /// # Arguments
    /// - `text_type`: The type of text representation to use when printing the QR code
    /// - `disc_caps`: The discovery capabilities to be used in the QR code payload
    pub fn print_standard_qr_code(
        &self,
        text_type: QrTextType,
        disc_caps: DiscoveryCapabilities,
    ) -> Result<(), Error> {
        // Also print the pairing code for convenience
        info!(
            "PairingCode: [{}]",
            self.dev_comm.compute_pretty_pairing_code()
        );

        let rx_buf = self.transport_mgr.rx_buffer();

        let mut buf = rx_buf.get_immediate().ok_or(ErrorCode::NoMemory)?;
        let buf = &mut *buf;

        let payload = self.standard_qr_payload(disc_caps)?;

        let (text, buf) = payload.as_str(buf)?;

        let (tmp_buf, out_buf) = buf.split_at_mut(buf.len() / 2);

        let qr = Qr::compute(text, tmp_buf, out_buf)?;

        const BORDER_SIZE: u8 = 4;

        for y in qr.lines_range(text_type, BORDER_SIZE) {
            info!(
                "{}",
                qr.line_as_str(text_type, BORDER_SIZE, false, false, y, tmp_buf)?
                    .0
            );
        }

        Ok(())
    }

    /// Return the standard QR code payload
    ///
    /// The returned QR code payload corresponds to the standard commissioning flow (i.e. `CommFlowType::Standard`)
    /// and contains no optional data.
    ///
    /// # Arguments
    /// - `disc_caps`: The discovery capabilities to be used in the QR code payload
    fn standard_qr_payload(
        &self,
        disc_caps: DiscoveryCapabilities,
    ) -> Result<QrPayload<'_, NoOptionalData>, Error> {
        let payload = QrPayload::new_from_basic_info(
            disc_caps,
            CommFlowType::Standard,
            self.dev_comm,
            self.dev_det,
            no_optional_data as _,
        );

        Ok(payload)
    }

    /// Return `true` if there is at least one commissioned fabric
    //
    // TODO:
    // The implementation of this method needs to change in future,
    // because the current implementation does not really track whether
    // `CommissioningComplete` had been actually received for the fabric.
    //
    // The fabric is created once we receive `AddNoc`, but that's just
    // not enough. The fabric should NOT be considered commissioned until
    // after we receive `CommissioningComplete` on behalf of a Case session
    // for the fabric in question.
    pub fn is_commissioned(&self) -> bool {
        self.fabric_mgr.borrow().iter().count() > 0
    }

    /// Open a basic commissioning window
    ///
    /// The method will return an error if the commissioning window cannot be opened
    /// (due to another window already being opened, for example).
    ///
    /// # Arguments
    /// - `timeout_secs`: The timeout in seconds for the basic commissioning window
    pub fn open_basic_comm_window<C: Crypto>(
        &self,
        timeout_secs: u16,
        crypto: C,
    ) -> Result<(), Error> {
        self.pase_mgr.borrow_mut().open_basic_comm_window(
            self.dev_comm.password,
            self.dev_comm.discriminator,
            timeout_secs,
            None,
            BasicContextInstance::new(self, crypto, self),
        )
    }

    /// Close the basic commissioning window
    ///
    /// The method will return Ok(false) if there is no active PASE commissioning window to close.
    pub fn close_comm_window<C: Crypto>(&self, crypto: C) -> Result<bool, Error> {
        self.pase_mgr
            .borrow_mut()
            .close_comm_window(BasicContextInstance::new(self, crypto, self))
    }

    /// Run the transport layer
    ///
    /// # Arguments
    /// - `send`: The network send interface
    /// - `recv`: The network receive interface
    /// - `crypto`: The crypto backend
    pub async fn run<S, R, C>(&self, send: S, recv: R, crypto: C) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
        C: Crypto,
    {
        self.run_transport(send, recv, crypto).await
    }

    /// Resets the transport layer by clearing all sessions, exchanges, the RX buffer and the TX buffer
    /// NOTE: User should be careful _not_ to call this method while the transport layer and/or the built-in mDNS is running.
    pub fn reset_transport(&self) -> Result<(), Error> {
        self.transport_mgr.reset()
    }

    /// Run the transport layer
    ///
    /// # Arguments
    /// - `send`: The network send interface
    /// - `recv`: The network receive interface
    /// - `crypto`: The crypto backend
    pub fn run_transport<'t, S, R, C>(
        &'t self,
        send: S,
        recv: R,
        crypto: C,
    ) -> impl Future<Output = Result<(), Error>> + 't
    where
        S: NetworkSend + 't,
        R: NetworkReceive + 't,
        C: Crypto + 't,
    {
        self.transport_mgr.run(send, recv, crypto)
    }

    /// Reset the Matter state by removing all fabrics and resetting basic info settings
    ///
    /// # Arguments
    /// - `flag_changed`: If true, notifies that fabrics and basic info settings have changed
    pub fn reset_persist(&self, flag_changed: bool) {
        self.basic_info_settings.borrow_mut().reset(flag_changed);
        self.fabric_mgr.borrow_mut().reset(flag_changed);

        self.notify_mdns();

        if flag_changed {
            self.notify_persist();
        }
    }

    /// Notify that the ACLs, Fabrics or Basic Info _might_ have changed
    /// This method is supposed to be called after processing SC and IM messages that might affect the ACLs, Fabrics or Basic Info.
    ///
    /// The default IM and SC handlers (`DataModel` and `SecureChannel`) do call this method after processing the messages.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    pub fn notify_persist(&self) {
        self.persist_notification.notify();
    }

    /// Load fabrics from the given data
    ///
    /// Arguments:
    /// - `data`: The data to load the fabrics from
    pub fn load_fabrics(&self, data: &[u8]) -> Result<(), Error> {
        self.fabric_mgr
            .borrow_mut()
            .load(data, &mut || self.notify_mdns())
    }

    /// Store fabrics into the given buffer
    ///
    /// Arguments:
    /// - `buf`: The buffer to store the fabrics into
    ///
    /// Returns the number of bytes written into the buffer.
    pub fn store_fabrics(&self, buf: &mut [u8]) -> Result<usize, Error> {
        self.fabric_mgr.borrow_mut().store(buf)
    }

    /// Return true if the fabrics have changed since the last call to `store_fabrics`
    pub fn fabrics_changed(&self) -> bool {
        self.fabric_mgr.borrow().is_changed()
    }

    /// Load basic info settings from the given data
    ///
    /// Arguments:
    /// - `data`: The data to load the basic info settings from
    pub fn load_basic_info(&self, data: &[u8]) -> Result<(), Error> {
        self.basic_info_settings.borrow_mut().load(data)
    }

    /// Store basic info settings into the given buffer
    ///
    /// Arguments:
    /// - `buf`: The buffer to store the basic info settings into
    ///
    /// Returns the number of bytes written into the buffer.
    pub fn store_basic_info(&self, buf: &mut [u8]) -> Result<usize, Error> {
        self.basic_info_settings.borrow_mut().store(buf)
    }

    /// Return true if the basic info settings have changed since the last call to `store_basic_info`
    pub fn basic_info_changed(&self) -> bool {
        self.basic_info_settings.borrow().changed
    }

    /// A hook for user persistence code to wait for potential changes in ACLs, Fabrics or basic info.
    ///
    /// Once this future resolves, user code is supposed to inspect ACLs, Fabrics and basic info for changes, and
    /// if there are changes, persist them.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    pub fn wait_persist(&self) -> impl Future<Output = ()> + '_ {
        self.persist_notification.wait()
    }

    /// Invoke the given closure for each currently published Matter mDNS service.
    pub fn mdns_services<C, F>(&self, crypto: C, mut f: F) -> Result<(), Error>
    where
        C: Crypto,
        F: FnMut(MatterMdnsService) -> Result<(), Error>,
    {
        debug!("=== Currently published mDNS services");

        let mut pase_mgr = self.pase_mgr.borrow_mut();
        let fabric_mgr = self.fabric_mgr.borrow();

        if let Some(comm_window) =
            pase_mgr.comm_window(BasicContextInstance::new(self, crypto, self))?
        {
            // Do not remove this logging line or change its formatting.
            // C++ E2E tests rely on this log line to determine when the mDNS service is published
            debug!("mDNS service published: {:?}", comm_window.mdns_service());

            f(comm_window.mdns_service())?;
        }

        for fabric in fabric_mgr.iter() {
            if let Some(service) = fabric.mdns_service() {
                // Do not remove this logging line or change its formatting.
                // C++ E2E tests rely on this log line to determine when the mDNS service is published
                debug!("mDNS service published: {:?}", service);

                f(service)?;
            }
        }

        debug!("===");

        Ok(())
    }

    /// Notify that the Matter mDNS services _might_ have changed.
    pub(crate) fn notify_mdns(&self) {
        self.mdns_notification.notify();
    }

    /// A hook for user code to wait for notification that the Matter mDNS services might have changed.
    ///
    /// Once this future resolves, user code is supposed to inspect the mDNS services for changes, and
    /// if there are changes, re-publish the changed mDNS services in an mDNS responder accordingly.
    pub fn wait_mdns(&self) -> impl Future<Output = ()> + '_ {
        self.mdns_notification.wait()
    }
}

impl ChangeNotify for Matter<'_> {
    fn notify(&self, _endpoint_id: EndptId, _cluster_id: ClusterId, _attr_id: AttrId) {
        // TODO: We're going to need some centralized way to notify subscriptions of attribute changes
        // Specifically, this is about internal changes - see for example usage in PaseMgr
    }
}
