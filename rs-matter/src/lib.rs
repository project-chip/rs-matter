/*
 *
 *    Copyright (c) 2020-2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

//! Native Rust Implementation of Matter (Smart-Home)
//!
//! This crate implements the Matter specification that can be run on embedded devices
//! to build Matter-compatible smart-home/IoT devices.
//!
//! Currently Ethernet based transport is supported.
//!
//! # Examples
//! ```ignore
//! /// TODO: Fix once new API has stabilized a bit
//! use rs_matter::{Matter, CommissioningData};
//! use rs_matter::dm::device_types::device_type_add_on_off_light;
//! use rs_matter::dm::cluster_basic_information::BasicInfoConfig;
//! use rs_matter::sc::spake2p::VerifierData;
//!
//! # use rs_matter::dm::sdm::dev_att::{DataType, DevAttDataFetcher};
//! # use rs_matter::error::Error;
//! # pub struct DevAtt{}
//! # impl DevAttDataFetcher for DevAtt{
//! # fn get_devatt_data(&self, data_type: DataType, data: &mut [u8]) -> Result<usize, Error> { Ok(0) }
//! # }
//! # let dev_att = Box::new(DevAtt{});
//!
//! /// The commissioning data for this device
//! let comm_data = CommissioningData {
//!     verifier: VerifierData::new_with_pw(123456),
//!     discriminator: 250,
//! };
//!
//! /// The basic information about this device
//! let dev_info = BasicInfoConfig {
//!     vid: 0x8000,
//!     pid: 0xFFF1,
//!     hw_ver: 2,
//!     sw_ver: 1,
//!     sw_ver_str: "1".to_string(),
//!     serial_no: "aabbcc".to_string(),
//!     device_name: "OnOff Light".to_string(),
//! };
//!
//! /// Get the Matter Object
//! /// The dev_att is an object that implements the DevAttDataFetcher trait.
//! let mut matter = Matter::new(dev_info, dev_att, comm_data).unwrap();
//! let dm = matter.get_data_model();
//! {
//!     let mut node = dm.node.write().unwrap();
//!     /// Add our device-types
//!     let endpoint = device_type_add_on_off_light(&mut node).unwrap();
//! }
//! // Start the Matter Daemon
//! // matter.start_daemon().unwrap();
//! ```
//!
//! Start off exploring by going to the [Matter] object.
#![cfg_attr(not(feature = "std"), no_std)]
#![allow(async_fn_in_trait)]
#![allow(unknown_lints)]
#![allow(clippy::uninlined_format_args)]
#![recursion_limit = "1024"]

use embassy_sync::blocking_mutex::raw::NoopRawMutex;

use crate::dm::clusters::basic_info::{BasicInfoConfig, BasicInfoSettings};
use crate::dm::clusters::dev_att::DevAttDataFetcher;
use crate::error::{Error, ErrorCode};
use crate::fabric::FabricMgr;
use crate::failsafe::FailSafe;
use crate::pairing::{print_pairing_code_and_qr, DiscoveryCapabilities};
use crate::sc::pake::PaseMgr;
use crate::transport::network::{NetworkReceive, NetworkSend};
use crate::transport::{PacketBufferExternalAccess, TransportMgr};
use crate::utils::cell::RefCell;
use crate::utils::epoch::Epoch;
use crate::utils::init::{init, Init};
use crate::utils::rand::Rand;
use crate::utils::storage::pooled::BufferAccess;
use crate::utils::storage::WriteBuf;
use crate::utils::sync::Notification;

/// Re-export the `rs_matter_macros::import` proc-macro
pub use rs_matter_macros::import;

#[cfg(feature = "alloc")]
extern crate alloc;

// This mod MUST go first, so that the others see its macros.
pub(crate) mod fmt;

pub mod acl;
pub mod cert;
pub mod crypto;
pub mod dm;
pub mod error;
pub mod fabric;
pub mod failsafe;
pub mod group_keys;
pub mod im;
pub mod pairing;
pub mod persist;
pub mod respond;
pub mod sc;
pub mod tlv;
pub mod transport;
pub mod utils;

/// Re-export several crates
///
/// This is necessary for crates used in the code generated by the proc-macros
pub mod reexport {
    pub use bitflags;
    #[cfg(feature = "defmt")]
    pub use defmt;
    #[cfg(feature = "log")]
    pub use log;
    pub use strum;
}

#[cfg(feature = "alloc")]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        alloc::boxed::Box::new($val)
    };
}

#[cfg(not(feature = "alloc"))]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        $val
    };
}

/// The Matter UDP port
pub const MATTER_PORT: u16 = 5540;

/// The maximum length of a Matter mDNS service name
pub const MATTER_SERVICE_MAX_NAME_LEN: usize = 33;

/// A type capturing all the information necessary to publish a commissioned
/// Matter fabric or a non-commissioned Matter instance over mDNS.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum MatterMdnsService {
    /// A commissioned Matter service for a particular fabric
    ///
    /// The published name is in the form `<compressed-fabric-id-hex>-<node-id-hex>`.
    Commissioned {
        compressed_fabric_id: u64,
        node_id: u64,
    },
    /// A non-commissioned Matter service
    ///
    /// The published name is in the form `<id-hex>`. The discriminator should be used as an mDNS TXT entry
    Commissionable {
        id: u64,
        /// The discriminator to be communicated over mDNS
        discriminator: u16,
    },
}

impl MatterMdnsService {
    /// Return the name of the mDNS service in a buffer
    ///
    /// NOTE: The buffer needs to be at least `MATTER_SERVICE_MAX_NAME_LEN` bytes long
    /// or else this method will panic.
    pub fn name<'a>(&self, buf: &'a mut [u8]) -> &'a str {
        use core::fmt::Write;

        match self {
            Self::Commissioned {
                compressed_fabric_id,
                node_id,
            } => {
                if buf.len() < MATTER_SERVICE_MAX_NAME_LEN {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", compressed_fabric_id);

                unwrap!(wb.append(b"-"));

                write_unwrap!(&mut wb, "{:016X}", node_id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
            Self::Commissionable { id, .. } => {
                if buf.len() < 16 {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
        }
    }
}

/// Device basic commissioning data
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct BasicCommData {
    /// The password which is necessary to authenticate the device in either
    /// initial commissioning, or when the basic commissioning window is opened
    pub password: u32,
    /// The 12-bit discriminator used to differentiate between multiple devices
    pub discriminator: u16,
}

/// The primary Matter Object
pub struct Matter<'a> {
    pub fabric_mgr: RefCell<FabricMgr>, // Public for tests
    pub(crate) pase_mgr: RefCell<PaseMgr>,
    pub(crate) failsafe: RefCell<FailSafe>,
    pub(crate) basic_info_settings: RefCell<BasicInfoSettings>,
    pub transport_mgr: TransportMgr, // Public for tests
    persist_notification: Notification<NoopRawMutex>,
    mdns_notification: Notification<NoopRawMutex>,
    epoch: Epoch,
    rand: Rand,
    dev_det: &'a BasicInfoConfig<'a>,
    dev_comm: BasicCommData,
    dev_att: &'a dyn DevAttDataFetcher,
    port: u16,
}

impl<'a> Matter<'a> {
    /// Create a new Matter object when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    #[inline(always)]
    pub const fn new_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        port: u16,
    ) -> Self {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::new(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create a new Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[inline(always)]
    pub const fn new(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> Self {
        Self {
            fabric_mgr: RefCell::new(FabricMgr::new()),
            pase_mgr: RefCell::new(PaseMgr::new(epoch, rand)),
            failsafe: RefCell::new(FailSafe::new(epoch, rand)),
            transport_mgr: TransportMgr::new(dev_det, epoch, rand),
            basic_info_settings: RefCell::new(BasicInfoSettings::new()),
            persist_notification: Notification::new(),
            mdns_notification: Notification::new(),
            epoch,
            rand,
            dev_det,
            dev_comm,
            dev_att,
            port,
        }
    }

    /// Create an in-place initializer for a Matter object
    /// when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    pub fn init_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        port: u16,
    ) -> impl Init<Self> {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::init(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create an in-place initializer for a Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    pub fn init(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> impl Init<Self> {
        init!(
            Self {
                fabric_mgr <- RefCell::init(FabricMgr::init()),
                pase_mgr <- RefCell::init(PaseMgr::init(epoch, rand)),
                failsafe: RefCell::new(FailSafe::new(epoch, rand)),
                transport_mgr <- TransportMgr::init(dev_det, epoch, rand),
                basic_info_settings <- RefCell::init(BasicInfoSettings::init()),
                persist_notification: Notification::new(),
                mdns_notification: Notification::new(),
                epoch,
                rand,
                dev_det,
                dev_comm,
                dev_att,
                port,
            }
        )
    }

    pub fn initialize_transport_buffers(&self) -> Result<(), Error> {
        self.transport_mgr.initialize_buffers()
    }

    pub fn dev_det(&self) -> &BasicInfoConfig<'_> {
        self.dev_det
    }

    pub fn dev_att(&self) -> &dyn DevAttDataFetcher {
        self.dev_att
    }

    pub fn dev_comm(&self) -> &BasicCommData {
        &self.dev_comm
    }

    pub fn port(&self) -> u16 {
        self.port
    }

    pub fn rand(&self) -> Rand {
        self.rand
    }

    pub fn epoch(&self) -> Epoch {
        self.epoch
    }

    pub fn transport_rx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.rx_buffer()
    }

    pub fn transport_tx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.tx_buffer()
    }

    /// A utility method to replace the initial Device Attestation Data Fetcher with another one.
    pub fn replace_dev_att(&mut self, dev_att: &'a dyn DevAttDataFetcher) {
        self.dev_att = dev_att;
    }

    /// Return `true` if there is at least one commissioned fabric
    //
    // TODO:
    // The implementation of this method needs to change in future,
    // because the current implementation does not really track whether
    // `CommissioningComplete` had been actually received for the fabric.
    //
    // The fabric is created once we receive `AddNoc`, but that's just
    // not enough. The fabric should NOT be considered commissioned until
    // after we receive `CommissioningComplete` on behalf of a Case session
    // for the fabric in question.
    pub fn is_commissioned(&self) -> bool {
        self.fabric_mgr.borrow().iter().count() > 0
    }

    /// Enable basic commissioning by setting up a PASE session and printing the pairing code and QR code.
    ///
    /// The method will return an error if there is not enough space in the buffer to print the pairing code and QR code
    /// or if the PASE session could not be set up (due to another PASE session already being active, for example).
    ///
    /// Parameters:
    /// * `discovery_capabilities`: The discovery capabilities of the device (IP, BLE or Soft-AP)
    /// * `timeout_secs`: The timeout in seconds for the basic commissioning session
    pub async fn enable_basic_commissioning(
        &self,
        discovery_capabilities: DiscoveryCapabilities,
        timeout_secs: u16,
    ) -> Result<(), Error> {
        let buf_access = PacketBufferExternalAccess(&self.transport_mgr.rx);
        let mut buf = buf_access.get().await.ok_or(ErrorCode::NoSpace)?;

        self.pase_mgr.borrow_mut().enable_basic_pase_session(
            self.dev_comm.password,
            self.dev_comm.discriminator,
            timeout_secs,
            &mut || self.notify_mdns(),
        )?;

        print_pairing_code_and_qr(
            self.dev_det,
            &self.dev_comm,
            discovery_capabilities,
            &mut buf,
        )?;

        Ok(())
    }

    /// Disable the basic commissioning session
    ///
    /// The method will return Ok(false) if there is no active PASE session to disable.
    pub fn disable_commissioning(&self) -> Result<bool, Error> {
        self.pase_mgr
            .borrow_mut()
            .disable_pase_session(&mut || self.notify_mdns())
    }

    /// Run the transport layer
    ///
    /// Enables basic commissioning if the device is not commissioned
    /// Note that the fabrics should be loaded by the PSM before calling this method
    /// or else commissioning will be always enabled.
    pub async fn run<S, R>(
        &self,
        send: S,
        recv: R,
        discovery_capabilities: DiscoveryCapabilities,
    ) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        // TODO: Figure out why chip-tool-tests expect the device to still be in commissioning mode
        // post device reboot, even if it was already commissioned
        if !self.is_commissioned() {
            self.enable_basic_commissioning(discovery_capabilities, 0 /*TODO*/)
                .await?;
        }

        self.run_transport(send, recv).await
    }

    /// Resets the transport layer by clearing all sessions, exchanges, the RX buffer and the TX buffer
    /// NOTE: User should be careful _not_ to call this method while the transport layer and/or the built-in mDNS is running.
    pub fn reset_transport(&self) -> Result<(), Error> {
        self.transport_mgr.reset()
    }

    /// Run the transport layer
    pub async fn run_transport<S, R>(&self, send: S, recv: R) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        self.transport_mgr.run(send, recv).await
    }

    /// Notify that the ACLs, Fabrics or Basic Info _might_ have changed
    /// This method is supposed to be called after processing SC and IM messages that might affect the ACLs, Fabrics or Basic Info.
    ///
    /// The default IM and SC handlers (`DataModel` and `SecureChannel`) do call this method after processing the messages.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    pub fn notify_persist(&self) {
        if self.fabrics_changed() || self.basic_info_changed() {
            self.persist_notification.notify();
        }
    }

    pub fn load_fabrics(&self, data: &[u8]) -> Result<(), Error> {
        self.fabric_mgr
            .borrow_mut()
            .load(data, &mut || self.notify_mdns())
    }

    pub fn store_fabrics<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        self.fabric_mgr.borrow_mut().store(buf)
    }

    pub fn fabrics_changed(&self) -> bool {
        self.fabric_mgr.borrow().is_changed()
    }

    pub fn load_basic_info(&self, data: &[u8]) -> Result<(), Error> {
        self.basic_info_settings.borrow_mut().load(data)
    }

    pub fn store_basic_info<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        self.basic_info_settings.borrow_mut().store(buf)
    }

    pub fn basic_info_changed(&self) -> bool {
        self.basic_info_settings.borrow().changed
    }

    /// A hook for user persistence code to wait for potential changes in ACLs, Fabrics or basic info.
    ///
    /// Once this future resolves, user code is supposed to inspect ACLs, Fabrics and basic info for changes, and
    /// if there are changes, persist them.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    pub async fn wait_persist(&self) {
        self.persist_notification.wait().await
    }

    pub fn mdns_services<F>(&self, mut f: F) -> Result<(), Error>
    where
        F: FnMut(MatterMdnsService) -> Result<(), Error>,
    {
        let pase_mgr = self.pase_mgr.borrow();
        let fabric_mgr = self.fabric_mgr.borrow();

        if let Some(service) = pase_mgr.mdns_service() {
            f(service)?;
        }

        for fabric in fabric_mgr.iter() {
            if let Some(service) = fabric.mdns_service() {
                f(service)?;
            }
        }

        Ok(())
    }

    /// Notify that the Matter mDNS services _might_ have changed.
    pub(crate) fn notify_mdns(&self) {
        self.mdns_notification.notify();
    }

    /// A hook for user code to wait for notification that the Matter mDNS services might have changed.
    ///
    /// Once this future resolves, user code is supposed to inspect the mDNS services for changes, and
    /// if there are changes, re-publish the changed mDNS services in an mDNS responder accordingly.
    pub async fn wait_mdns(&self) {
        self.mdns_notification.wait().await
    }
}
